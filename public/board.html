<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="icon" href="/images/favicon.ico">
    <meta name="description" content="Join real-time multi-user whiteboard" />
		<meta name="author" content="Lelsers Lasers" />
		<meta
			name="keywords"
			content="whiteboard draw websocket realtime real time multiuser multi-user multi user online"
		/>
    <title id="title">MultiBoard: Join</title>


    <!-- Pico.css (Classless version) -->
    <!-- <link
        rel="stylesheet"
        href="https://cdn.jsdelivr.net/npm/@picocss/pico@1/css/pico.classless.min.css"
    /> -->

    <script src="https://cdn.socket.io/4.6.1/socket.io.min.js"></script>

    <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            /* display: flex;
            flex-direction: column;
            justify-content: center; */

            background-color: #eceff4;
            color: #2e3440;

            font-family: Calibri, sans-serif;
            font-size: 16px;

            font-family: system-ui, "Segoe UI", Roboto, Oxygen, Ubuntu, Cantarell, Helvetica, Arial, "Helvetica Neue", sans-serif;
        }

        canvas {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            cursor: none;
            display: block;
            background-color: #eceff4;
        }

        div {
            margin: 0;
            padding: 0;
        }

        #topbar {
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            align-items: center;
            padding: 0.75em;
            background-color: #ECEFF4;
            z-index: 1;
            border-radius: 0.5em;
            box-shadow: 0.3em 0.3em 0.8em #d8dee9;

            position: fixed;
            top: 0.5em;
            left: 50%;
            transform: translate(-50%, 0);
        }

        #bottombar {
            display: flex;
            flex-direction: row;
            justify-content: space-between;
            align-items: center;
            padding: 0.75em;
            background-color: #ECEFF4;
            z-index: 1;
            border-radius: 0.5em;
            box-shadow: 0.3em 0.3em 0.8em #d8dee9;

            position: fixed;
            bottom: 1em;
            left: 50%;
            transform: translate(-50%, 0);
        }

        .separator {
            width: 0.2em;
            height: 1.5em;
            border-radius: 0.5em;
            background-color: #2E3440;
            margin: 0 0.5em;
        }

        #id {
            white-space: nowrap;
            margin: 0;
        }

        button {
            background-color: #ECEFF4;
            border: none;
            box-shadow: 0.1em 0.1em 0.3em #4c566a;
            border-radius: 0.5em;
            white-space: nowrap;
            margin: 0;
            padding: 0.5em 0.8em;
            cursor: pointer;
        }
        button:hover {
            background-color: #e5e9f0;
        }


        .color {
            width: 1.5em;
            height: 1.5em;
            border-radius: 0.5em;
            cursor: pointer;
        }
        #color1 { background-color: #BF616A; }
        #color2 { background-color: #A3BE8C; }
        #color3 { background-color: #EBCB8B; }
        #color4 { background-color: #5E81AC; }
        .colorSpacer {
            width: 0.5em;
        }
        .colorSelected {
            box-shadow: 0.1em 0.1em 0.3em #4c566a;
        }



        /* .spacing {
            content: "";
            display: block;
            margin: 0.3em;
        }
        hr {
            background-color: #ECEFF4;
            border: none;
            height: 1px;
            border-radius: 10px;
        }

        label {
            color: #ECEFF4;
            height: 1.2em;
            font-size: 1em;
            cursor: pointer;
        }

        input {
            height: 1.2em;
            font-size: 1em;
            padding: 0.8em 0.5em;
            box-sizing: border-box;
            background-color: #4C566A;
            color: #ECEFF4;
            border-radius: 7px;
            border: none;
            outline: none !important;
        }
        input:focus {
            outline: 2px solid #EBCB8B !important;
        }
        input[type="color"] {
            width: default;
            padding: 0.15em;
            height: 1.8em;
            transform: translate(0, 0.2em);
        }
        input[type="checkbox"] {
            width: 0.9em;
            height: 1.1em;
            padding: 0px;
            margin: 0px;
            margin-bottom: 0.15em;
            vertical-align: middle;
            position: relative;
            color: #ECEFF4;
            outline: none !important;
            cursor: pointer;
        }
        input[type="range"] {
            width: 100%;
            color: #ECEFF4;
            outline: none !important;
            border: none !important;
            padding: 0;
            margin: 0;
        }

        button {
            font-size: 1em;
            border: none;
            padding: 0.3em 2em;
            background-color: #5E81AC;
            color: #ECEFF4;
            cursor: pointer;
            border-radius: 7px;
            width: 100%;
            margin-bottom: 0.5em;
            outline: none;
        }
        button:focus {
            outline: 2px solid #EBCB8B;
        }
        .smallInput {
            width: 3em;
        } */
    </style>
</head>

<body onresize="resize()">
    <canvas id="canvas"></canvas>

    <div id="topbar">
        <p id="id">ID: ?</p>
        <div class="separator"></div>

        <button id="copy" onclick="copyLink()">Copy Link</button>
        <div class="separator"></div>

        <button id="clear" onclick="clearBoard()">Clear</button>
        <div class="separator"></div>

        <button id="save" onclick="saveAsPng()">Save as PNG</button>
        <div class="separator"></div>

        <button id="back" onclick="back()">Exit</button>
    </div>

    <div id="bottombar">
        <div id="color1" class="color colorSelected"></div>
        <div class="colorSpacer"></div>
        <div id="color2" class="color"></div>
        <div class="colorSpacer"></div>
        <div id="color3" class="color"></div>
        <div class="colorSpacer"></div>
        <div id="color4" class="color"></div>
        <div class="separator"></div>

        <label for="erase">Eraser: </label>
        <input type="checkbox" id="erase" name="erase" />
        <div class="separator"></div>

        <label for="size">Size: </label>
        <output>25</output>
        <input type="range" id="size" name="size" min="1" max="200" step="1" value="25" oninput="this.previousElementSibling.value = this.value" />
        <div class="separator"></div>

        <button id="clear" onclick="clearBoard()">Clear</button>
    </div>
</body>

<script>
    const url = window.location.href;
    const boardId = url.substring(url.lastIndexOf("/") + 1);
    document.getElementById("title").innerHTML = `MultiBoard: ${boardId}`;
    document.getElementById("id").innerHTML = `ID: ${boardId}`;


    const socket = io();
    socket.emit("requestBoard", boardId);


    const canvas = document.getElementById("canvas");
    const ctx = canvas.getContext("2d");
    const BACKGROUND_COLOR = "#ECEFF4";

    const INPUT_TIMEOUT = 5 * 1000;
    const INPUT_DELETE_TIMEOUT = 5 * 60 * 1000;

    let penColor = "#BF616A";


    let mouseDown = false;
    let mouseX = 0;
    let mouseY = 0;

    let lines =  {};
    let mice = {};

    let currentLine = {};
    let currentLineId = null;

    let redraw = true;

    function createId() {
        const id = Math.random().toString(36).substring(2, 7).toUpperCase();
        if (lines[id]) {
            return createId();
        }
        return id;
    }


    function inputStart(clientX, clientY) {
        mouseDown = true;

        const rect = canvas.getBoundingClientRect();
        mouseX = (clientX - rect.left) / canvas.width;
        mouseY = (clientY - rect.top) / canvas.height;

        currentLineId = createId();
        const eraser = document.getElementById("erase").checked;
        currentLine = {
            color: !eraser ? penColor : BACKGROUND_COLOR,
            size: parseInt(document.getElementById("size").value),
            points: [{
                mouseX,
                mouseY,
            }],
        };
        socket.emit('createLine', { boardId, lineId: currentLineId, line: currentLine });
    }

    function inputMove(clientX, clientY) {
        const rect = canvas.getBoundingClientRect();
        mouseX = (clientX - rect.left) / canvas.width;
        mouseY = (clientY - rect.top) / canvas.height;

        if (mouseDown) {
            const pt = {
                mouseX,
                mouseY,
            };

            socket.emit('updateLine', { boardId, lineId: currentLineId, pt });
        }

        socket.emit('inputMove', { boardId, mouseX, mouseY });
        redraw = true;
    }

    function colorClick(id) {
        // penColor = document.getElementById(id).style.backgroundColor;
        // console.log(document.getElementById(id));
        const e = document.getElementById(id);
        const bg = e.style.backgroundColor;
        if (!bg) {
            const css = window.getComputedStyle(e);
            penColor = css.backgroundColor;
        } else {
            penColor = bg;
        }

        const ids = ["color1", "color2", "color3", "color4"];
        for (const i of ids) {
            document.getElementById(i).classList.remove("colorSelected");
        }
        e.classList.add("colorSelected");
    }

    canvas.addEventListener("touchstart", (e) => inputStart(e.touches[0].clientX, e.touches[0].clientY));
    canvas.addEventListener("touchend", (e) => mouseDown = false);
    canvas.addEventListener("touchmove", (e) => inputMove(e.touches[0].clientX, e.touches[0].clientY));

    canvas.addEventListener("mousedown", (e) => inputStart(e.clientX, e.clientY));
    canvas.addEventListener("mouseup", (e) => mouseDown = false);
    canvas.addEventListener("mousemove", (e) => inputMove(e.clientX, e.clientY));

    document.getElementById("color1").addEventListener("click", () => colorClick("color1"));
    document.getElementById("color2").addEventListener("click", () => colorClick("color2"));
    document.getElementById("color3").addEventListener("click", () => colorClick("color3"));
    document.getElementById("color4").addEventListener("click", () => colorClick("color4"));

    function clearBoard() {
        socket.emit("clear", boardId);
    }

    socket.on(`lines`, (newLines) => {
        lines = newLines;
        redraw = true;
    });
    socket.on(`lineCreate`, ({ lineId, line }) => {
        lines[lineId] = line;
        redraw = true;
    });
    socket.on(`lineUpdate`, ({ lineId, pt }) => {
        lines[lineId].points.push(pt);
        redraw = true;
    });
    socket.on(`mice`, (newMice) => {
        mice = newMice;
        redraw = true;
    });


    function resize() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }

    function back() {
        window.location.href = "/";
    }

    function saveAsPng() {
        const link = document.createElement("a");
        link.download = `${boardId}.png`;
        link.href = canvas.toDataURL("image/png");
        link.click();
    }

    let linkCopiedTimeout = null;
    function copyLink() {
        navigator.clipboard.writeText(url);
        document.getElementById("copy").innerHTML = "Copied!";

        if (linkCopiedTimeout) clearTimeout(linkCopiedTimeout);

        linkCopiedTimeout = setTimeout(() => {
            document.getElementById("copy").innerHTML = "Copy link";
        }, 3000);
    }

    
    //--------------------------------------------------------------------------------------------//
    function loop() {
        let redraw_queue = false;
        //----------------------------------------------------------------------------------------//
        if (redraw) {
            ctx.fillStyle = BACKGROUND_COLOR;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            for (const lineId in lines) {
                const line = lines[lineId];

                ctx.strokeStyle = line.color;
                ctx.fillStyle = line.color;
                ctx.lineWidth = Math.max(line.size * canvas.width / 5000, 1);

                const startX = line.points[0].mouseX * canvas.width;
                const startY = line.points[0].mouseY * canvas.height;

                ctx.beginPath();
                ctx.ellipse(startX, startY, ctx.lineWidth / 2, ctx.lineWidth / 2, 0, 0, 2 * Math.PI);
                ctx.fill();

                
                ctx.beginPath();
                ctx.moveTo(startX, startY);

                for (let i = 0; i < line.points.length; i++) {
                    const { mouseX, mouseY } = line.points[i];
                    ctx.lineTo(mouseX * canvas.width, mouseY * canvas.height);
                }
                const { mouseX, mouseY } = line.points[line.points.length - 1];
                ctx.lineTo(mouseX * canvas.width, mouseY * canvas.height);

                ctx.stroke();

                const endX = line.points[line.points.length - 1].mouseX * canvas.width;
                const endY = line.points[line.points.length - 1].mouseY * canvas.height;

                ctx.beginPath();
                ctx.ellipse(endX, endY, ctx.lineWidth / 2, ctx.lineWidth / 2, 0, 0, 2 * Math.PI);
                ctx.fill();
            }
        }

        //----------------------------------------------------------------------------------------//
        const now = Date.now();
        for (const socketId in mice) {
            if (socketId == socket.id) continue;

            const mouse = mice[socketId];
            if (mouse.timestamp + INPUT_TIMEOUT < now) {
                if (mouse.timestamp + INPUT_DELETE_TIMEOUT < now) {
                    socket.emit("inputDelete", { boardId, socketId });
                }
                redraw_queue = true;
                continue;
            }

            ctx.fillStyle = mouse.color;

            ctx.beginPath();
            ctx.ellipse(mouse.mouseX * canvas.width, mouse.mouseY * canvas.height, 4, 4, 0, 0, 2 * Math.PI);
            ctx.fill();

            ctx.strokeStyle = BACKGROUND_COLOR;
            ctx.lineWidth = 1;

            ctx.beginPath();
            ctx.ellipse(mouse.mouseX * canvas.width, mouse.mouseY * canvas.height, 4, 4, 0, 0, 2 * Math.PI);
            ctx.stroke();
        }
        //----------------------------------------------------------------------------------------//

        //----------------------------------------------------------------------------------------//
        if (redraw) {
            const lineSize = parseInt(document.getElementById("size").value);
            const radius = Math.max(lineSize * canvas.width / 5000, 1) / 2;

            ctx.strokeStyle = BACKGROUND_COLOR;
            ctx.lineWidth = 3;

            ctx.beginPath();
            ctx.ellipse(mouseX * canvas.width, mouseY * canvas.height, radius, radius, 0, 0, 2 * Math.PI);
            ctx.stroke();

            2E3440
            ctx.strokeStyle = "#2E3440";
            ctx.lineWidth = 1;

            ctx.beginPath();
            ctx.ellipse(mouseX * canvas.width, mouseY * canvas.height, radius, radius, 0, 0, 2 * Math.PI);
            ctx.stroke();

            redraw = false;
        }
        //----------------------------------------------------------------------------------------//

        if (redraw_queue) redraw = true;
        window.requestAnimationFrame(loop);
    }
    //--------------------------------------------------------------------------------------------//


    resize();
    window.requestAnimationFrame(loop);
</script>